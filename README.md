# wx-weapp-preRequet
## 用法  
这只是一个简单粗暴的方法来实现 页面预请求  

你可以 clone 本库，并查看utils文件夹内部的 routerBus 文件

项目里的 index 和 logs 页面用到了页面预请求
### 一个简单的预请求实现
 * 首先在 app 全局 globalData 建立 两个空对象 pagesEvent  和 preData ，并引入该脚本
 * 跳转路由时使用 gotoRouter ,只支持绝对路径。
 * 在预加载页面重写 app.globalData.pagesEvent[pageName] pageName 为绝对路径，函数参数为路由参数的健值对
 * 在预加载页面onLoad 事件通过 app.globalData.preData[pageName] 获取事件返回结过
## 原理
我们先在小程序做个实验。

首先，在pageA 写一个跳转函数 wx.navigator 跳转到b页面，并且在这时缓存一个时间点 wx.saveTime = new Date()

然后在pageB页面的，onLoad 钩子函数中再得到当前时间，并减去之前缓存的时间点。

你会发现差值时100ms到200ms之间，（首次进入页面时会更久）相信如果性能差点的安卓机只高不低，但Page B页面的请求一般写在onload事件中，这就意味着，100ms-200ms的跳转过程时间被浪费掉了，

能否在跳转前就让 B 页面去请求呢？


你一定认为我疯了，B页面还没加载，怎么就能请求呢？难道请求要写在A页面，然后页面传值传过去？



不是这样的，其实小程序页面的运行机制是打开即运行。代码从微信服务器拉下来之后，不管页面需不需要，都会被执行一遍。我们可以来做个实验。



在小程序的log页面写一个定时器，每隔一秒打印一个值。

事实上，当小程序打开的时候，它就会打印一个值，以后不管页面如何跳转、如何被关闭，它始终都会打印这个值，这个定时器将伴随着小程序直到被内存杀掉。

（这警告了我们写类似定时器的长任务时，要主动去关闭。在onHide中）

既然所有的页面都存在于内存中，那么我们完全可以写一个 Event Bus，然后封装原生跳转事件，当页面跳转时，通知 Event Bus 去请求对应页面的请求事件，这样跳转和请求同时进行，

我们的页面初始请求会快100ms-200ms之间，其实，请求并没有变快，只是我们让它早”先“飞了一会儿。
